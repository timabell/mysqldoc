#!/usr/bin/perl 
# mysqldoc - Auto-Generate a data-dictionary

use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use DBI;
use Switch;

# Defaults
my $help = 0;
my $host;
my $user;
my $port;
my $database;
my $password = -1;
my $version = 0;
my $filename = 0;

my $result = GetOptions ( 'database=s' => \$database,
                          'file=s'     => \$filename,
                          'help'       => \$help,
                          'host:s'     => \$host,
                          'password:s' => \$password,
                          'port:i'     => \$port,
                          'user:s'     => \$user,
                          'version'    => \$version );

pod2usage(2) if $help;
__END__

=head1 NAME

mysqldoc - Auto-documentation for mysql schema

=head1 SYNOPSIS

mysqldoc [options]

  Options:
    --database=<database>      Database to use.
    --file=<filename>          The path and filename in which to save the output.
    --help                     Display this help and exit.
    --host=<hostname>          Connect to host.
    --password[=<password>]    Password to use when connecting to server. If password is
                               not given, it is asked from the tty.
    --port=#                   Port number to use for connection.
    --user=<username>          Username to use when connecting to server.
    --version                  Output version information and exit.
 
=head1 DESCRIPTION

mysqldoc is a tool for auto-documentation generation for MySQL 5.0 and above

=cut

if ($version) {

  print "mysqldoc 0.0.2\n";
  exit(1);

}

$host = $host ? $host : 'localhost';
$user = $user ? $user : 'root';

if ($password ne -1) {

  $password = $password ? $password : getPass();

} else {

  $password = '';

}

$port = $port ? $port : '3306';

my $dbh = DBI->connect("dbi:mysql:;host=$host;port=$port", $user, $password);

my %table_info = ();

my $table_query = $dbh->prepare("SELECT `table_name`, SUM(`DATA_LENGTH` + `INDEX_LENGTH`) / 1024 / 1024 AS `total_size`, `DATA_LENGTH` / 1024 / 1024 AS `DATA_LENGTH`, `INDEX_LENGTH` / 1024 / 1024 AS `INDEX_LENGTH`, `TABLE_COMMENT` FROM `INFORMATION_SCHEMA`.`TABLES` WHERE `TABLE_SCHEMA` = \"$database\" GROUP BY `table_name`");
$table_query->execute();

while (my $ref = $table_query->fetchrow_hashref()) {

  $table_info{ $ref->{ 'table_name' } } = { 'TOTAL_SIZE'   =>  $ref->{ 'total_size' },
                                            'DATA_LENGTH'  =>  $ref->{ 'DATA_LENGTH' },
                                            'INDEX_LENGTH' =>  $ref->{ 'INDEX_LENGTH' },
                                            'COMMENT'      =>  $ref->{ 'TABLE_COMMENT' } };

}

for my $table_name (keys(%table_info)) {

  my $column_query = $dbh->prepare("SELECT `column_name`, `DATA_TYPE`, `COLUMN_DEFAULT`, `COLUMN_COMMENT` FROM `INFORMATION_SCHEMA`.`COLUMNS` WHERE `TABLE_SCHEMA` = \"$database\" AND `TABLE_NAME` = \"$table_name\"");

  $column_query->execute();

  while (my $ref = $column_query->fetchrow_hashref()) {

    $table_info{$table_name}{'COLUMNS'}{ $ref->{ 'column_name' } } = { 'DATA_TYPE' => $ref->{ 'DATA_TYPE' },
                                                                       'DEFAULT'   => $ref->{ 'COLUMN_DEFAULT' }, 
                                                                       'COMMENT' => $ref->{ 'COLUMN_COMMENT' } };

  }
  
}

my $of = &format(%table_info, 'PlainText');

if ($filename) {

  open(OUTFILE, ">$filename") or die "Can't open $filename for writing : $!";;
  print OUTFILE $of;
  close(OUTFILE);

} else {

  print $of;

}

sub getPass {

  print "Password: ";
  system "stty -echo";
  chomp(my $passwd = <STDIN>);
  system "stty echo";
  print "\n";
  return $passwd;

}

sub format {

  # Valid formats are: XML, HTML, PlainText (default is PlainText)

  #my %input_hash = $_[0];
  my $format = $_[1];

  my $return_string = '';

  switch ($format) {

    case 'XML' {

    } case 'HTML' {

    } else {

      $return_string .= "\nDATA DICTIONARY FOR: $database\n\n";

      # PlainText Output 
      for my $table (keys(%table_info)) {

        $return_string .= "$table - $table_info{$table}{'DATA_LENGTH'} MB (DATA: $table_info{$table}{'DATA_LENGTH'} MB, INDEX: $table_info{$table}{'INDEX_LENGTH'} MB)\n";
        $return_string .= "  $table_info{$table}{'COMMENT'}\n";
       
        for my $column (keys(%{$table_info{$table}->{'COLUMNS'}})) {

          $return_string .= "  $column - $table_info{$table}{'COLUMNS'}{$column}{'DATA_TYPE'}";

          if ($table_info{$table}{'COLUMNS'}{$column}{'DEFAULT'}) {

            $return_string .= "  DEFAULT $table_info{$table}{'COLUMNS'}{$column}{'DEFAULT'}";
  
          }

          $return_string .= "\n      $table_info{$table}{'COLUMNS'}{$column}{'COMMENT'}\n";

        }

      }

    }

  }

  return $return_string; 
}
