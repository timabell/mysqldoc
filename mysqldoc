#!/opt/local/bin/perl
# mysqldoc - Auto-Generate a data-dictionary

##########
# TO DO:
#
# Finish baseHTML.xsl
# Finish baseTXT.xsl
# Finish baseWIKI.xsl 
# Get rid of all unused code & variables
# Combine all the get()s into one function!
# Config file (perhaps import Config?) 
# 
##########

=pod

=head1 NAME

mysqldoc - Auto-documentation for mysql schema

=head1 SYNOPSIS

mysqldoc [options]

  Options:
    --databases=<database>[,<database>[,...]]
                                 Database(s) to use.  Comma-Separated, if more than one.
    --file=<filename>            The path and filename in which to save the output.
    --help                       Display this help and exit.
    --host=<hostname>            Connect to host.
    --output=[XML | HTML | TXT]  The format in which to generate the output.    
    --password[=<password>]      Password to use when connecting to server. If password is
                                 not given, it is asked from the tty.
    --port=#                     Port number to use for connection.
    --print-defaults             Print the program argument list and exit.
    --size[=B | KB | MB | GB | TB]
                                 Show storage size (for tables, indexes, and databases).
    --socket                     Socket file to use for connection. 
    --tables=<table>[,<table>[,...]]
                                 Enumerated list of tables for the script to be run against.
                                 Each table must be specified with both database and table
                                 names, e.g. database_name.table_name.
    --ignore-tables=<table>[,<table>[,...]]
                                 Enumerated list of tables to be skipped (all unnamed tables
                                 will be included).  Each table must be specified with both
                                 database and table names, e.g. database_name.table_name.
    --user=<username>            Username to use when connecting to server.
    --version                    Output version information and exit.

=head1 DESCRIPTION

mysqldoc is a tool for auto-documentation generation for MySQL 5.0 and above

=cut

pod2usage(2) if ($#ARGV eq -1);

use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use DBI;
use XML::XSLT;

my $mysqldoc_version = '0.0.9';

# Defaults
my @databases;
my $filename = 0;
my $help = 0;
my $host;
my $user;
my $port = 3306;
my $password = -1;
my $version;
my $output = 'TXT';
my $defaults;
my $socket = -1;
my @included_tables;
my @excluded_tables;
my $storage = 'MB';

my $result = GetOptions ( 'databases=s'        => \@databases,
                          'file=s'             => \$filename,
                          'help'               => \$help,
                          'host:s'             => \$host,
                          'output=s'           => \$output,
                          'password:s'         => \$password,
                          'port:i'             => \$port,
                          'print-defaults'     => \$defaults,
                          'show-size:s'        => \$storage,
                          'socket=s'           => \$socket,
                          'tables=s'           => \@included_tables,
                          'ignore-tables=s'    => \@excluded_tables,
                          'user:s'             => \$user,
                          'version'            => \$version );

pod2usage(1) if $help;

if ($version) {

  print "mysqldoc $mysqldoc_version (Check for updates at: http://code.google.com/p/mysqldoc)\n";
  exit(1);

}

if ($defaults) {

  print "mysqldoc defaults are:

ATTRIBUTE                  VALUE
-------------------------- ------------------
databases                  (No default value)
file                       (No default value)
help                       FALSE
host                       (No default volue)
output                     txt
password                   (No default value)
port                       3306
print-defaults             FALSE
show-size                  TRUE (MB)
socket                     (No default value)
tables                     (No default value)
ignore-tables              (No default value)
user                       (No default value)
version                    FALSE
";

  exit(1);
}

if (!@databases) { die("You must specify at least one database\n"); }

@databases = split(/,/, join(',', @databases));

@included_tables = split(',', join(',', @included_tables)); 
@excluded_tables = split(',', join(',', @excluded_tables));

$host = $host ? $host : 'localhost';
$user = $user ? $user : 'root';

if ($password ne -1) {

  $password = $password ? $password : &getPass();

} else {

  $password = '';

}

$storage = uc($storage);

$port = $port ? $port : '3306';

my $connection_string = "dbi:mysql:;host=$host;port=$port";

if ($socket ne -1) {

  $connection_string .= ";mysql_socket=$socket";

}

my $dbh = eval { DBI->connect($connection_string, $user, $password, {'RaiseError' => 1}); }; die("Could Not Connect To: $host") if ($@);

my $mvq = $dbh->prepare("SELECT SUBSTRING(\@\@version, 1, 3) mysql_version") 
                        or die "Couldn't prepare statement: " . $dbh->errstr;
$mvq->execute() or die "Couldn't execute statement: " . $dbh->errstr;
my $mysql_version = $mvq->fetchrow() or die "fetchrow error";

my $tsq = $dbh->prepare("SELECT NOW()") 
                        or die "Couldn't prepare statement: " . $dbh->errstr;
$tsq->execute() or die "Couldn't execute statement: " . $dbh->errstr;
my $ts = $tsq->fetchrow() or die "fetchrow error";

my %doc_info = ();

foreach my $database (@databases) {

  &getBaseInfo($database);

  for my $table_name (keys(%{$doc_info{ $database }{ 'TABLES' } })) {

    &getIndexInfo($database, $table_name);
 
  }   

  for my $table_name (keys(%{$doc_info{ $database }{ 'TABLES' } })) {

    &getTriggerInfo($database, $table_name);

  }

  &getUdfInfo($database);

}

# BUILD THE XML DOCTYPE INFO
my $return_string = "<?xml version=\"1.0\" encoding=\"utf-8\" ?>

<!DOCTYPE databases [
  <!ELEMENT databases (database*)>
  <!ELEMENT database (table*)>
  <!ELEMENT table (column*, index*, trigger*)>
  <!ELEMENT column (data_type, default_value, comment)>
  <!ELEMENT index (index_type, indexed_column*)>
  <!ELEMENT trigger (action_timing, event_manipulation, action_statement?)>

  <!ELEMENT data_type (#PCDATA)>
  <!ELEMENT default_value (#PCDATA)>
  <!ELEMENT comment (#PCDATA)>
  <!ELEMENT index_type (#PCDATA)>
  <!ELEMENT indexed_column (#PCDATA)>
  <!ELEMENT action_timing (#PCDATA)>
  <!ELEMENT event_manipulation (#PCDATA)>
  <!ELEMENT action_statement (#PCDATA)>

  <!ATTLIST databases timestamp CDATA #REQUIRED>
  <!ATTLIST databases mysqldoc_version CDATA #REQUIRED>
  <!ATTLIST database name CDATA #REQUIRED>

  <!ATTLIST table name CDATA #REQUIRED
                  type CDATA #REQUIRED
                  engine CDATA #IMPLIED
                  total_size CDATA #IMPLIED
                  data_size CDATA #IMPLIED
                  index_size CDATA #IMPLIED>
  <!ATTLIST column name CDATA #REQUIRED>
  <!ATTLIST index name CDATA #REQUIRED>
  <!ATTLIST indexed_column seq_in_index CDATA #REQUIRED>
  <!ATTLIST trigger name CDATA #REQUIRED>

]>

<databases mysqldoc_version=\"$mysqldoc_version\">";

# POPULATE THE XML
for my $database (keys %doc_info) {

  $return_string .= "\n<database name='$database'>\n";

  for my $table (keys(%{$doc_info{ $database }{ 'TABLES' } })) {

    $return_string .= "  <table name='$table' type='$doc_info{ $database }{ 'TABLES' }{ $table }{ 'TABLE_TYPE' }'"; 

    if ($doc_info{ $database }{ 'TABLES' }{ $table }{ 'TABLE_TYPE' } ne 'VIEW') {

      $return_string .= " engine='$doc_info{ $database }{ 'TABLES' }{ $table }{ 'ENGINE' }'";
      $return_string .= " total_size='" . &convertStorage($doc_info{ $database }{ 'TABLES' }{ $table }{ 'TOTAL_SIZE' });
      $return_string .= " data_size='" . &convertStorage($doc_info{ $database }{ 'TABLES' }{ $table }{ 'DATA_LENGTH' });
      $return_string .= " index_size='" . &convertStorage($doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEX_LENGTH' }); 

    }

    $return_string .= ">\n";

    for my $column (sort ascend_num keys %{$doc_info{ $database }{ 'TABLES' }{ $table }{ 'COLUMNS' } }) {

      $return_string .= "    <column name='$doc_info{ $database }{ 'TABLES' }{ $table }{ 'COLUMNS' }{ $column }{ 'COLUMN_NAME' }'>\n";
      $return_string .= "      <data_type>";

      $return_string .= $doc_info{ $database }{ 'TABLES' }{ $table }{ 'COLUMNS' }{ $column }{ 'DATA_TYPE' };

      $return_string .= "</data_type>\n";
      $return_string .= "      <default_value>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'COLUMNS' }{ $column }{ 'DEFAULT' }</default_value>\n"; 
      $return_string .= "      <comment>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'COLUMNS' }{ $column }{ 'COMMENT' }</comment>\n";
      $return_string .= "    </column>\n";

    }

    for my $index (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table }->{ 'INDEXES' } })) {

      $return_string .= "    <index name='$index'>\n";
      $return_string .= "      <index_type>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }{ 'INDEX_TYPE' }</index_type>\n";

      my $column_count = keys %{$doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }{ 'COLUMNS' } };

      if ($column_count gt 1) {

        for (my $i = 1; $i < $column_count + 1; $i++) {

          for my $i_col (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }->{ 'COLUMNS' } })) {

            if ($doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }{ 'COLUMNS' }{ $i_col }->{ 'SEQ_IN_INDEX' } eq $i) {

              $return_string .= "      <indexed_column seq_in_index='$doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }{ 'COLUMNS' }{ $i_col }->{ 'SEQ_IN_INDEX' }'>$i_col</indexed_column>\n";

            }

          }
 
        }

      } else {

        # This sucks, but I don't know another way
        for my $s (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }{ 'COLUMNS' } })) {

          $return_string .= "      <indexed_column seq_in_index='1'>$s</indexed_column>\n";

        }

      }

      $return_string .= "    </index>\n";

    }


    for my $trigger (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table }->{ 'TRIGGERS' } })) {

      $return_string .= "    <trigger name='$trigger'>\n";
      $return_string .= "      <action_timing>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'TRIGGERS' }{ $trigger }{ 'ACTION_TIMING' }</action_timing>\n";
      $return_string .= "      <event_manipulation>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'TRIGGERS' }{ $trigger }{ 'EVENT_MANIPULATION' }</event_manipulation>\n";
      $return_string .= "      <action_statement>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'TRIGGERS' }{ $trigger }{ 'ACTION_STATEMENT' }</action_statement>\n";
      $return_string .= "    </trigger>\n";


    }

    $return_string .= "  </table>\n\n";

  }

    for my $udf (keys(%{$doc_info{ $database }{ 'PROCEDURES' } })) {

      $return_string .= "  <procedure name='$udf' type='$doc_info{ $database }{ 'PROCEDURES' }{ $udf }{ 'ROUTINE_TYPE' }'>\n";

      $return_string .= "      <td><pre>$doc_info{ $database }{ 'PROCEDURES' }{ $udf }{ 'ROUTINE_DEFINITION' }</pre></td>\n";

      $return_string .= "\n  </procedure>\n";

  }

  $return_string .= "</database>\n";

}

$return_string .= "</databases>";

print "$return_string\n";

sub getBaseInfo($$) {

  my $database = $_[0];

  my $sql = "SELECT `t`.`TABLE_NAME`,
                    `t`.`TABLE_TYPE`,
                    `t`.`ENGINE`,
                    IFNULL(`t`.`DATA_LENGTH`, 0) AS `DATA_LENGTH`,
                    IFNULL(`t`.`INDEX_LENGTH`, 0) AS `INDEX_LENGTH`,
                    `t`.`TABLE_COMMENT`,
                    `c`.`COLUMN_NAME`,
                    `c`.`COLUMN_TYPE`,
                    IFNULL(`c`.`CHARACTER_MAXIMUM_LENGTH`, `c`.`NUMERIC_PRECISION`) AS `MAX_LENGTH`,
                    IFNULL(`c`.`COLUMN_DEFAULT`, IF(`c`.`IS_NULLABLE` = 'NO','','NULL')) AS `COLUMN_DEFAULT`,
                    `c`.`COLUMN_COMMENT`,
                    `c`.`ORDINAL_POSITION`
               FROM `INFORMATION_SCHEMA`.`TABLES` `t`
               JOIN `INFORMATION_SCHEMA`.`COLUMNS` `c` ON (`t`.`TABLE_SCHEMA` = `c`.`TABLE_SCHEMA` AND `t`.`TABLE_NAME` = `c`.`TABLE_NAME`)
                 WHERE `t`.`TABLE_SCHEMA` = \"$database\"";

  if (scalar @included_tables gt 0) {

    my $asql;
    my $i = 0;

    foreach my $combo (@included_tables) {

      if ($combo =~ /\./ && $database eq substr($combo, 0, index($combo,'.'))) {

        if ($i gt 0) { $asql .= " OR "; }
        $asql .= " (`t`.`TABLE_SCHEMA` = \"" . substr($combo, 0, index($combo,'.')) . "\" AND `t`.`TABLE_NAME` = \"" . substr($combo, index($combo,'.') + 1) . "\")";  
        $i++;
 
      } 

    }  

    if ($i gt 0) {

      $sql .= ' AND (' . $asql . ')';

    }

  } elsif (scalar @excluded_tables gt 0) {

    my $asql;
    my $i = 0;

    foreach my $combo (@excluded_tables) {

      if ($combo =~ /./ && $database eq substr($combo, 0, index($combo,'.'))) {

        if ($i gt 0) { $asql .= " AND "; }
        $asql .= " (`t`.`TABLE_SCHEMA` = \"" . substr($combo, 0, index($combo,'.')) . "\" AND `t`.`TABLE_NAME` != \"" . substr($combo, index($combo,'.') + 1) . "\")"; 
        $i++;

      }

    }

    if ($i gt 0) {

      $sql .= ' AND (' . $asql . ')';

    }

  }

  $sql .= ' ORDER BY `t`.`TABLE_NAME`, `c`.`ORDINAL_POSITION` DESC';

  my $query = $dbh->prepare($sql) or die "Couldn't prepare statement: " . $dbh->errstr;

  $query->execute() or die "Couldn't execute statement: " . $dbh->errstr;

  while (my $ref = $query->fetchrow_hashref()) {

    unless (exists($doc_info{ $database }{ 'TABLES' }{ $ref->{ 'TABLE_NAME' } })) {

      $doc_info{ $database }{ 'TABLES' }{ $ref->{ 'TABLE_NAME' } } = { 'TABLE_TYPE'   => $ref->{ 'TABLE_TYPE' },
                                                                       'ENGINE'       => $ref->{ 'ENGINE' },
                                                                       'TOTAL_SIZE'   => $ref->{ 'DATA_LENGTH' } + $ref->{ 'INDEX_LENGTH' },
                                                                       'DATA_LENGTH'  => $ref->{ 'DATA_LENGTH' },
                                                                       'INDEX_LENGTH' => $ref->{ 'INDEX_LENGTH' },
                                                                       'COMMENT'      => $ref->{ 'TABLE_COMMENT' } };

    }

    $doc_info{ $database }{ 'TABLES' }{ $ref->{ 'TABLE_NAME' } }{ 'COLUMNS' }{ $ref->{ 'ORDINAL_POSITION' } } = { 'COLUMN_NAME'      => $ref->{ 'COLUMN_NAME' },
                                                                                                                  'DATA_TYPE'        => $ref->{ 'COLUMN_TYPE' },
                                                                                                                  'MAX_LENGTH'       => $ref->{ 'MAX_LENGTH' },
                                                                                                                  'DEFAULT'          => $ref->{ 'COLUMN_DEFAULT' },
                                                                                                                  'COMMENT'          => $ref->{ 'COLUMN_COMMENT' } };
  
  }

}

sub getIndexInfo($$) {

  my $database = $_[0];
  my $table_name = $_[1];

  my $index_query = $dbh->prepare("SELECT `INDEX_NAME`, `COLUMN_NAME`, `SEQ_IN_INDEX` FROM `INFORMATION_SCHEMA`.`STATISTICS`
                                   WHERE `TABLE_SCHEMA` = \"$database\" AND `TABLE_NAME` = \"$table_name\" GROUP BY `INDEX_NAME`,
                                   `COLUMN_NAME` ORDER BY `INDEX_NAME`, `SEQ_IN_INDEX`") or die "Couldn't prepare statement: " . $dbh->errstr;

  $index_query->execute() or die "Couldn't execute statement: " . $dbh->errstr;

  while (my $ref = $index_query->fetchrow_hashref()) {

    $doc_info{ $database }{ 'TABLES' }{ $table_name }{ 'INDEXES '}{ $ref->{ 'INDEX_NAME' } }{ 'COLUMNS' }{ $ref->{ 'COLUMN_NAME' } } = { 'SEQ_IN_INDEX' => $ref->{ 'SEQ_IN_INDEX' } };

  }

  for my $index (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table_name }{ 'INDEXES' } })) {

    my $itq = $dbh->prepare("SELECT DISTINCT `INDEX_TYPE` FROM `INFORMATION_SCHEMA`.`STATISTICS` WHERE `TABLE_SCHEMA` = \"$database\" AND
                            `TABLE_NAME` = \"$table_name\" AND `INDEX_NAME` = \"$index\"") or die "Couldn't prepare statement: " . $dbh->errstr;

    $itq->execute() or die "Couldn't execute statement: " . $dbh->errstr;

    $doc_info{ $database }{ 'TABLES' }{ $table_name }{ 'INDEXES' }{ $index }{ 'INDEX_TYPE' } =  $itq->fetchrow();

  }

}

sub getTriggerInfo($$) {

  my $database = $_[0];
  my $table_name = $_[1];

  my $trigger_query = $dbh->prepare("SELECT `trigger_name`, `action_timing`, `event_manipulation`, `action_statement` FROM `INFORMATION_SCHEMA`.`TRIGGERS`
                                    WHERE `TRIGGER_SCHEMA` = \"$database\" AND `EVENT_OBJECT_TABLE` = \"$table_name\"") or die "Couldn't prepare statement: " . $dbh->errstr;

  $trigger_query->execute() or die "Couldn't execute statement: " . $dbh->errstr;

  while (my $ref = $trigger_query->fetchrow_hashref()) {

    $doc_info{ $database }{ 'TABLES' }{ $table_name }{ 'TRIGGERS' }{ $ref->{ 'trigger_name' } } = { 'ACTION_TIMING'      => $ref->{ 'action_timing' },
                                                                                                    'EVENT_MANIPULATION' => $ref->{ 'event_manipulation' },
                                                                                                    'ACTION_STATEMENT'   => $ref->{ 'action_statement' } };

  }

}

sub getUdfInfo($$) {

  my $database = $_[0];

  my $udf_query = $dbh->prepare("SELECT `ROUTINE_NAME`, `ROUTINE_TYPE`, `ROUTINE_DEFINITION` FROM `INFORMATION_SCHEMA`.`ROUTINES` WHERE `ROUTINE_SCHEMA` = \"$database\"") or die "Couldn't prepare statement: " . $dbh->errstr;

  $udf_query->execute() or die "Couldn't execute statement: " . $dbh->errstr;

  while (my $ref = $udf_query->fetchrow_hashref()) {

    $doc_info{ $database }{ 'PROCEDURES' }{ $ref->{ 'ROUTINE_NAME' } } = { 'ROUTINE_TYPE'       => $ref->{ 'ROUTINE_TYPE' },
                                                                           'ROUTINE_DEFINITION' => $ref->{ 'ROUTINE_DEFINITION' } };

  }

}

sub ascend_num {$a <=> $b}

sub convertStorage($$) {

  my $size = uc($_[0]);

  return ($size . " B") if ($size eq 'B');
  return (($size / 1024) . " KB") if ($size eq 'KB');
  return (($size / 1024 / 1024) . " GB") if ($size eq 'GB');
  return (($size / 1024 / 1204 / 1204) . " TB") if ($size eq 'TB');
  return (($size / 1024 / 1024) . " MB"));

}
