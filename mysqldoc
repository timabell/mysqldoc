#!/usr/bin/perl 
# mysqldoc - Auto-Generate a data-dictionary

=pod

=head1 NAME

mysqldoc - Auto-documentation for mysql schema

=head1 SYNOPSIS

mysqldoc [options]

  Options:
    --database=<database>        Database to use.
    --file=<filename>            The path and filename in which to save the output.
    --help                       Display this help and exit.
    --host=<hostname>            Connect to host.
    --html-links                 Include HTML hyperlinks (only in HTML output) to
                                 relevant MySQL documentation.
    --no-html-links              Do not include links to MySQL documentation.
    --output=[XML | HTML | TXT]  The format in which to generate the output.    
    --password[=<password>]      Password to use when connecting to server. If password is
                                 not given, it is asked from the tty.
    --port=#                     Port number to use for connection.
    --show-engines               Show the storage engine for each table.
    --no-show-engines            Do not show the storage engine for each table.
    --show-indexes               Show the indexes on each table.
    --no-show-indexes            Do not show the indexes on each table.
    --user=<username>            Username to use when connecting to server.
    --version                    Output version information and exit.

=head1 DESCRIPTION

mysqldoc is a tool for auto-documentation generation for MySQL 5.0 and above

=cut

use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use DBI;
use Switch;

# Defaults
my $help = 0;
my $host;
my $user;
my $port;
my $database;
my $password = -1;
my $version;
my $filename = 0;
my $engines = 1;
my $output = 0;
my $links = 1;
my $indexes = 0;

my $result = GetOptions ( 'database=s'    => \$database,
                          'file=s'        => \$filename,
                          'help'          => \$help,
                          'host:s'        => \$host,
                          'html-links!'   => \$links,
                          'show-indexes!' => \$indexes,
                          'output=s'      => \$output,
                          'password:s'    => \$password,
                          'port:i'        => \$port,
                          'show-engines!' => \$engines,
                          'user:s'        => \$user,
                          'version'       => \$version );

pod2usage(2) if $help;

if ($version) {

  print "mysqldoc 0.0.5\n";
  exit(1);

}

$host = $host ? $host : 'localhost';
$user = $user ? $user : 'root';

if ($password ne -1) {

  $password = $password ? $password : &getPass();

} else {

  $password = '';

}

$port = $port ? $port : '3306';

my $dbh = DBI->connect("dbi:mysql:;host=$host;port=$port", $user, $password);

my $mvq = $dbh->prepare("SELECT SUBSTRING(\@\@version, 1, 3) mysql_version");
$mvq->execute();
my $mysql_version = $mvq->fetchrow();

my %table_info = ();

my $table_query = $dbh->prepare("SELECT `table_name`, `TABLE_TYPE`, `engine`, SUM(`DATA_LENGTH` + `INDEX_LENGTH`) / 1024 / 1024 AS `total_size`, `DATA_LENGTH` / 1024 / 1024 AS `DATA_LENGTH`, `INDEX_LENGTH` / 1024 / 1024 AS `INDEX_LENGTH`, `TABLE_COMMENT` FROM `INFORMATION_SCHEMA`.`TABLES` WHERE `TABLE_SCHEMA` = \"$database\" GROUP BY `table_name`");
$table_query->execute();

while (my $ref = $table_query->fetchrow_hashref()) {

  $table_info{ $ref->{ 'table_name' } } = { 'TOTAL_SIZE'   =>  $ref->{ 'total_size' },
                                            'TABLE_TYPE'   =>  $ref->{ 'TABLE_TYPE' },
                                            'ENGINE'       =>  $ref->{ 'engine' },
                                            'DATA_LENGTH'  =>  $ref->{ 'DATA_LENGTH' },
                                            'INDEX_LENGTH' =>  $ref->{ 'INDEX_LENGTH' },
                                            'COMMENT'      =>  $ref->{ 'TABLE_COMMENT' } };

}

for my $table_name (keys(%table_info)) {

  my $column_query = $dbh->prepare("SELECT `column_name`, `DATA_TYPE`, IFNULL(`COLUMN_DEFAULT`,'NULL') AS `COLUMN_DEFAULT`, `COLUMN_COMMENT` FROM `INFORMATION_SCHEMA`.`COLUMNS` WHERE `TABLE_SCHEMA` = \"$database\" AND `TABLE_NAME` = \"$table_name\"");

  $column_query->execute();

  while (my $ref = $column_query->fetchrow_hashref()) {

    $table_info{$table_name}{'COLUMNS'}{ $ref->{ 'column_name' } } = { 'DATA_TYPE' =>  $ref->{ 'DATA_TYPE' },
                                                                       'DEFAULT'   =>  $ref->{ 'COLUMN_DEFAULT' }, 
                                                                       'COMMENT'   =>  $ref->{ 'COLUMN_COMMENT' } };

  }
  
}

if ($indexes eq 1) {

  for my $table_name (keys(%table_info)) {

    my $index_query = $dbh->prepare("SELECT `INDEX_NAME`, `COLUMN_NAME`, `SEQ_IN_INDEX` FROM `INFORMATION_SCHEMA`.`STATISTICS` WHERE `TABLE_SCHEMA` = \"$database\" AND `TABLE_NAME` = \"$table_name\" GROUP BY `INDEX_NAME`, `COLUMN_NAME` ORDER BY `INDEX_NAME`, `SEQ_IN_INDEX`");

    $index_query->execute();

    while (my $ref = $index_query->fetchrow_hashref()) {

      $table_info{$table_name}{'INDEXES'}{ $ref->{ 'INDEX_NAME' } }{ 'COLUMNS' }{ $ref->{ 'COLUMN_NAME' } } = { 'SEQ_IN_INDEX' => $ref->{ 'SEQ_IN_INDEX' } };

    }

    for my $index (keys(%{$table_info{$table_name}{'INDEXES'}})) {

      my $itq = $dbh->prepare("SELECT DISTINCT `INDEX_TYPE` FROM `INFORMATION_SCHEMA`.`STATISTICS` WHERE `TABLE_SCHEMA` = \"$database\" AND `TABLE_NAME` = \"$table_name\" AND `INDEX_NAME` = \"$index\"");

      $itq->execute();

      $table_info{$table_name}{'INDEXES'}{ $index }{ 'INDEX_TYPE' } =  $itq->fetchrow();
 
    }
 
  } 

}   

#use Data::Dumper;
#print Dumper(%table_info);
#exit;


my $return_string = '';

switch ($output) {

  case 'XML' {

    $return_string .= "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n";

    $return_string .= "<!DOCTYPE database [
  <!ELEMENT database (table*)>
  <!ELEMENT table (column*, index*)>
  <!ELEMENT column (data_type, default_value, comment)>
  <!ELEMENT index (index_type, indexed_column*)>

  <!ELEMENT data_type (#PCDATA)>
  <!ELEMENT default_value (#PCDATA)>
  <!ELEMENT comment (#PCDATA)>
  <!ELEMENT index_type (#PCDATA)>
  <!ELEMENT indexed_column (#PCDATA)>

  <!ATTLIST database name CDATA #REQUIRED>
  <!ATTLIST table name CDATA #REQUIRED
                  type CDATA #REQUIRED
                  engine CDATA #IMPLIED>
  <!ATTLIST column name CDATA #REQUIRED>
  <!ATTLIST index name CDATA #REQUIRED>
  <!ATTLIST indexed_column seq_in_index CDATA #REQUIRED>

]>\n";
   
    $return_string .= "\n<database name='$database'>\n";
 
    for my $table (keys(%table_info)) {

      $return_string .= "  <table name='$table' type='$table_info{$table}{'TABLE_TYPE'}'";

      $return_string .= " engine='$table_info{$table}{'ENGINE'}'" if ($engines eq 1);

      $return_string .= ">\n";

      for my $column (keys(%{$table_info{$table}->{'COLUMNS'}})) {

        $return_string .= "    <column name='$column'>\n";
        $return_string .= "      <data_type>$table_info{$table}{'COLUMNS'}{$column}{'DATA_TYPE'}</data_type>\n";
        $return_string .= "      <default_value>$table_info{$table}{'COLUMNS'}{$column}{'DEFAULT'}</default_value>\n"; 
        $return_string .= "      <comment>$table_info{$table}{'COLUMNS'}{$column}{'COMMENT'}</comment>\n";
        $return_string .= "    </column>\n";

      }

      if ($indexes eq 1) {

        for my $index (keys(%{$table_info{$table}->{'INDEXES'}})) {

          $return_string .= "    <index name='$index'>\n";
          $return_string .= "      <index_type>$table_info{$table}{'INDEXES'}{$index}{'INDEX_TYPE'}</index_type>\n";

          my $column_count = keys %{$table_info{$table}{'INDEXES'}{$index}{'COLUMNS'}};

          if ($column_count gt 1) {

            for (my $i = 1; $i < $column_count + 1; $i++) {

              for my $i_col (keys(%{$table_info{$table}{'INDEXES'}{$index}->{'COLUMNS'}})) {

                if ($table_info{$table}{'INDEXES'}{$index}{'COLUMNS'}{$i_col}->{'SEQ_IN_INDEX'} eq $i) {

                   $return_string .= "      <indexed_column seq_in_index='$table_info{$table}{'INDEXES'}{$index}{'COLUMNS'}{$i_col}->{'SEQ_IN_INDEX'}'>$i_col</indexed_column>\n";

                }

              }

            }

          } else {

            # This sucks, but I don't know another way
            for my $s (keys(%{$table_info{$table}{'INDEXES'}{$index}{'COLUMNS'}})) {

              $return_string .= "      <indexed_column seq_in_index='1'>$s</indexed_column>\n";

            }

          }

        $return_string .= "    </index>\n";
        }

      }

      $return_string .= "  </table>\n\n";

    }

    $return_string .= "</database>";

  } case 'HTML' {

    $return_string .= '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">' . "\n\n";
    $return_string .= '<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">';
    $return_string .= "\n\n<head>\n  <title>DATA DICTIONARY FOR: $database</title>\n</head>\n\n<body>\n\n";
    $return_string .= "<table border='1'>\n  <tr><td align='center' colspan='3'><strong>DATA DICTIONARY FOR: $database</strong></td></tr>\n";

    for my $table (keys(%table_info)) {

      $return_string .= "  <tr><td><strong>$table</strong> ";

      $return_string .= "- ($table_info{$table}{'TABLE_TYPE'}";

      if ($engines eq 1) {

        $return_string .= " ";

        if ($links eq 1) {

          switch ($table_info{$table}{'ENGINE'}) {

            case 'InnoDB' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/innodb.html'>"; }
            case 'MyISAM' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/myisam-storage-engine.html'>"; }
            case 'MEMORY' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/memory-storage-engine.html'>"; } 
            case 'MERGE' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/merge-storage-engine.html'>"; }
            case 'BDB' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/bdb-storage-engine.html'>"; }
            case 'EXAMPLE' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/example-storage-engine.html'>"; }
            case 'FEDERATED' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/federated-storage-engine.html'>"; }
            case 'ARCHIVE' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/archive-storage-engine.html'>"; }
            case 'CSV' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/csv-storage-engine.html'>"; }
            case 'BLACKHOLE' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/blackhole-storage-engine.html'>"; }
          
          }
     
        }

        $return_string .= "$table_info{$table}{'ENGINE'} ";

        $return_string .= "</a>" if ($links eq 1);

      }

      $return_string .= ") ";

      $return_string .= "</td><td colspan='2'>$table_info{$table}{'DATA_LENGTH'} MB (DATA: $table_info{$table}{'DATA_LENGTH'} MB, INDEX: $table_info{$table}{'INDEX_LENGTH'} MB)</td></tr>\n";

      $return_string .= "  <tr><td></td><td colspan='2'>$table_info{$table}{'COMMENT'}</td></tr>\n" if ($table_info{$table}{'COMMENT'});
 
      for my $column (keys(%{$table_info{$table}->{'COLUMNS'}})) {

        $return_string .= "  <tr><td></td><td colspan='2'><em>$column</em> - $table_info{$table}{'COLUMNS'}{$column}{'DATA_TYPE'}";

        $return_string .= "  DEFAULT $table_info{$table}{'COLUMNS'}{$column}{'DEFAULT'}" if ($table_info{$table}{'COLUMNS'}{$column}{'DEFAULT'});

        $return_string .= "</td></tr>\n";

        $return_string .= "  <tr><td></td><td colspan='2'>&nbsp;&nbsp;&nbsp;&nbsp;$table_info{$table}{'COLUMNS'}{$column}{'COMMENT'}</td></tr>\n" if ($table_info{$table}{'COLUMNS'}{$column}{'COMMENT'});

      }

      if ($indexes eq 1) {

        for my $index (keys(%{$table_info{$table}->{'INDEXES'}})) {

          $return_string .= "  <tr><td></td><td colspan='2'><em>$index</em> ($table_info{$table}{'INDEXES'}{$index}{'INDEX_TYPE'} INDEX)</td></tr>\n    <tr><td></td><td colspan='2'>&nbsp;&nbsp;&nbsp;&nbsp;";

          my $column_count = keys %{$table_info{$table}{'INDEXES'}{$index}{'COLUMNS'}};

          if ($column_count gt 1) {

            for (my $i = 1; $i < $column_count + 1; $i++) {

              for my $i_col (keys(%{$table_info{$table}{'INDEXES'}{$index}->{'COLUMNS'}})) {

                if ($table_info{$table}{'INDEXES'}{$index}{'COLUMNS'}{$i_col}->{'SEQ_IN_INDEX'} eq $i) {

                  $return_string .= "$i_col";

                  $return_string .= ($i < $column_count) ? ", " : "</td></tr>\n";

                }

              }

            }

          } else {

            # This sucks, but I don't know another way
            for my $s (keys(%{$table_info{$table}{'INDEXES'}{$index}{'COLUMNS'}})) {

              $return_string .= "$s</td></tr>\n\n";

            }

          }

        }

      }

    }

    $return_string .= "\n</table>\n\n</body>\n\n</html>";

  } else {

    $return_string .= "\nDATA DICTIONARY FOR: $database\n\n";

    for my $table (keys(%table_info)) {

      $return_string .= "$table - ($table_info{$table}{'TABLE_TYPE'}";

      $return_string .= " $table_info{$table}{'ENGINE'}" if ($engines eq 1);

      $return_string .= ") $table_info{$table}{'DATA_LENGTH'} MB (DATA: $table_info{$table}{'DATA_LENGTH'} MB, INDEX: $table_info{$table}{'INDEX_LENGTH'} MB)\n";
      $return_string .= "  $table_info{$table}{'COMMENT'}\n";
       
      for my $column (keys(%{$table_info{$table}->{'COLUMNS'}})) {

        $return_string .= "  $column - $table_info{$table}{'COLUMNS'}{$column}{'DATA_TYPE'}";

        $return_string .= "  DEFAULT $table_info{$table}{'COLUMNS'}{$column}{'DEFAULT'}" if ($table_info{$table}{'COLUMNS'}{$column}{'DEFAULT'});

        $return_string .= "\n      $table_info{$table}{'COLUMNS'}{$column}{'COMMENT'}\n";

      }

      if ($indexes eq 1) {

        for my $index (keys(%{$table_info{$table}->{'INDEXES'}})) {

          $return_string .= "  $index ($table_info{$table}{'INDEXES'}{$index}{'INDEX_TYPE'} INDEX)\n      ";

          my $column_count = keys %{$table_info{$table}{'INDEXES'}{$index}{'COLUMNS'}};

          if ($column_count gt 1) {
 
            for (my $i = 1; $i < $column_count + 1; $i++) {

              for my $i_col (keys(%{$table_info{$table}{'INDEXES'}{$index}->{'COLUMNS'}})) {

                if ($table_info{$table}{'INDEXES'}{$index}{'COLUMNS'}{$i_col}->{'SEQ_IN_INDEX'} eq $i) {

                  $return_string .= "$i_col";

                  $return_string .= ($i < $column_count) ? ", " : "\n";

                }

              }

            }

          } else {

            # This sucks, but I don't know another way
            for my $s (keys(%{$table_info{$table}{'INDEXES'}{$index}{'COLUMNS'}})) {

              $return_string .= "$s\n";

            }

          }
 
        }

      }

    }

  }

}

if ($filename) {

  open(OUTFILE, ">$filename") or die "Can't open $filename for writing : $!";
  print OUTFILE $return_string;
  close(OUTFILE);

} else {

  print $return_string;

}

sub getPass {

  print "Password: ";
  system "stty -echo";
  chomp(my $passwd = <STDIN>);
  system "stty echo";
  print "\n";
  return $passwd;

}

