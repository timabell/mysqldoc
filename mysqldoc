#!/usr/bin/perl 
# mysqldoc - Auto-Generate a data-dictionary

=pod

=head1 NAME

mysqldoc - Auto-documentation for mysql schema

=head1 SYNOPSIS

mysqldoc [options]

  Options:
    --databases=<database>[,<database>[,...]]
                                 Database(s) to use.  Comma-Separated, if more than one.
    --file=<filename>            The path and filename in which to save the output.
    --help                       Display this help and exit.
    --host=<hostname>            Connect to host.
    --html-links                 Include HTML hyperlinks (only in HTML output) to
                                 relevant MySQL documentation.
    --no-html-links              Do not include links to MySQL documentation.
    --output=[XML | HTML | TXT]  The format in which to generate the output.    
    --password[=<password>]      Password to use when connecting to server. If password is
                                 not given, it is asked from the tty.
    --port=#                     Port number to use for connection.
    --print-defaults             Print the program argument list and exit.
    --show-engines               Show the storage engine for each table.
    --no-show-engines            Do not show the storage engine for each table.
    --show-indexes               Show the indexes on each table.
    --no-show-indexes            Do not show the indexes on each table.
    --show-triggers              Show TRIGGERS associated with each table.
    --no-show-triggers           Do not show TRIGGERS associated with each table.
    --show-trigger-body          Show TRIGGER bodies (implies --show-triggers).
    --no-show-trigger-body       Do not show TRIGGER bodies.
    --show-udf                   Show User-Defined Functions.
    --no-show-udf                Do not show User-Defined Functions.
    --show-udf-body              Show UDF bodies (implies --show-udf).
    --no-show-udf-body           Do not show UDF bodies.
    --timestamp                  Show the database timestamp for when the documentation
                                 was generated.
    --no-timestamp               Do not show the timestamp of doc generation.
    --user=<username>            Username to use when connecting to server.
    --version                    Output version information and exit.

=head1 DESCRIPTION

mysqldoc is a tool for auto-documentation generation for MySQL 5.0 and above

=cut

pod2usage(2) if ($#ARGV eq -1);

use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use DBI;
use Switch;

my $mysqldoc_version = '0.0.7';

# Defaults
my $help = 0;
my $host;
my $user;
my $port = 3306;
my @databases;
my $password = -1;
my $version;
my $filename = 0;
my $engines = 1;
my $output = 'TXT';
my $links = 1;
my $indexes = 0;
my $timestamp = 0;
my $ts;
my $defaults;
my $triggers = 0;
my $trigger_bodies = 0;
my $udfs = 0;
my $udf_bodies = 0;

my $result = GetOptions ( 'databases=s'        => \@databases,
                          'file=s'             => \$filename,
                          'help'               => \$help,
                          'host:s'             => \$host,
                          'html-links!'        => \$links,
                          'show-indexes!'      => \$indexes,
                          'output=s'           => \$output,
                          'password:s'         => \$password,
                          'port:i'             => \$port,
                          'print-defaults'     => \$defaults,
                          'show-engines!'      => \$engines,
                          'show-triggers!'     => \$triggers,
                          'show-trigger-body!' => \$trigger_bodies,
                          'show-udf!'          => \$udfs,
                          'show-udf-body!'     => \$udf_bodies,
                          'timestamp!'         => \$timestamp,
                          'user:s'             => \$user,
                          'version'            => \$version );

pod2usage(2) if $help;

if ($version) {

  print "mysqldoc $mysqldoc_version (Check for updates at: http://code.google.com/p/mysqldoc)\n";
  exit(1);

}

if ($defaults) {

  print "mysqldoc defaults are:

ATTRIBUTE                  VALUE
-------------------------- ------------------
databases                  (No default value)
file                       (No default value)
help                       FALSE
host                       (No default volue)
html-links                 TRUE
show-indexes               FALSE
output                     txt
password                   (No default value)
port                       3306
print-defaults             FALSE
show-engines               TRUE
show-triggers              FALSE
show-trigger-body          FALSE
show-udf                   FALSE
show-udf-body              FOLSE
timestamp                  FALSE
user                       (No default value)
version                    FALSE
";

  exit(1);
}

@databases = split(/,/, join(',', @databases));

$host = $host ? $host : 'localhost';
$user = $user ? $user : 'root';

if ($password ne -1) {

  $password = $password ? $password : &getPass();

} else {

  $password = '';

}

$port = $port ? $port : '3306';

my $dbh = DBI->connect("dbi:mysql:;host=$host;port=$port", $user, $password);

my $mvq = $dbh->prepare("SELECT SUBSTRING(\@\@version, 1, 3) mysql_version") 
                        or die "Couldn't prepare statement: " . $dbh->errstr;
$mvq->execute() or die "Couldn't execute statement: " . $dbh->errstr;
my $mysql_version = $mvq->fetchrow();

if ($timestamp eq 1) {

  my $tsq = $dbh->prepare("SELECT NOW()") 
                          or die "Couldn't prepare statement: " . $dbh->errstr;
  $tsq->execute() or die "Couldn't execute statement: " . $dbh->errstr;
  $ts = $tsq->fetchrow();

}

my %doc_info = ();

foreach my $database (@databases) {

  &getBaseInfo($database);

  if ($indexes eq 1) {

    for my $table_name (keys(%{$doc_info{ $database }{ 'TABLES' } })) {

      &getIndexInfo($database, $table_name);
 
    } 

  }   

  if ($triggers eq 1 || $trigger_bodies eq 1) {

    for my $table_name (keys(%{$doc_info{ $database }{ 'TABLES' } })) {

      &getTriggerInfo($database, $table_name);

    }

  }

  &getUdfInfo($database) if ($udfs eq 1 || $udf_bodies eq 1);

}

# FOR DEBUG
#use Data::Dumper;
#print Dumper(%doc_info);
#exit;

my $return_string = &buildOutputHeaders(uc($output));

for my $database (keys %doc_info) {

  switch (uc($output)) {

    case 'XML' {

      $return_string .= "\n<database name='$database'";

      $return_string .= " timestamp='$ts'" if ($timestamp eq 1);

      $return_string .= ">\n";
 
      for my $table (keys(%{$doc_info{ $database }{ 'TABLES' } })) {

        $return_string .= "  <table name='$table' type='$doc_info{ $database }{ 'TABLES' }{ $table }{ 'TABLE_TYPE' }'"; 

        if ($doc_info{ $database }{ 'TABLES' }{ $table }{ 'TABLE_TYPE' } ne 'VIEW') {

          $return_string .= " engine='$doc_info{ $database }{ 'TABLES' }{ $table }{ 'ENGINE' }'" if ($engines eq 1);
          $return_string .= " total_size='$doc_info{ $database }{ 'TABLES' }{ $table }{ 'TOTAL_SIZE' } MB'";
          $return_string .= " data_size='$doc_info{ $database }{ 'TABLES' }{ $table }{ 'DATA_LENGTH' } MB'";
          $return_string .= " index_size='$doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEX_LENGTH' } MB'"; 

        }

        $return_string .= ">\n";

        for my $column (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table }{ 'COLUMNS' } })) {

          $return_string .= "    <column name='$column'>\n";
          $return_string .= "      <data_type>";

          $return_string .= $doc_info{ $database }{ 'TABLES' }{ $table }{ 'COLUMNS' }{ $column }{ 'DATA_TYPE' };

          $return_string .= "</data_type>\n";
          $return_string .= "      <default_value>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'COLUMNS' }{ $column }{ 'DEFAULT' }</default_value>\n"; 
          $return_string .= "      <comment>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'COLUMNS' }{ $column }{ 'COMMENT' }</comment>\n";
          $return_string .= "    </column>\n";

        }

        if ($indexes eq 1) {

          for my $index (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table }->{ 'INDEXES' } })) {

           $return_string .= "    <index name='$index'>\n";
           $return_string .= "      <index_type>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }{ 'INDEX_TYPE' }</index_type>\n";

           my $column_count = keys %{$doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }{ 'COLUMNS' } };

           if ($column_count gt 1) {

             for (my $i = 1; $i < $column_count + 1; $i++) {

               for my $i_col (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }->{ 'COLUMNS' } })) {

                 if ($doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }{ 'COLUMNS' }{ $i_col }->{ 'SEQ_IN_INDEX' } eq $i) {

                   $return_string .= "      <indexed_column seq_in_index='$doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }{ 'COLUMNS' }{ $i_col }->{ 'SEQ_IN_INDEX' }'>$i_col</indexed_column>\n";

                 }

               }
 
             }

           } else {

             # This sucks, but I don't know another way
             for my $s (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }{ 'COLUMNS' } })) {

               $return_string .= "      <indexed_column seq_in_index='1'>$s</indexed_column>\n";

             }

           }

          $return_string .= "    </index>\n";

        }

      }

      if ($triggers eq 1 || $trigger_bodies eq 1) {

        for my $trigger (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table }->{ 'TRIGGERS' } })) {

          $return_string .= "    <trigger name='$trigger'>\n";
          $return_string .= "      <action_timing>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'TRIGGERS' }{ $trigger }{ 'ACTION_TIMING' }</action_timing>\n";
          $return_string .= "      <event_manipulation>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'TRIGGERS' }{ $trigger }{ 'EVENT_MANIPULATION' }</event_manipulation>\n";
          $return_string .= "      <action_statement>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'TRIGGERS' }{ $trigger }{ 'ACTION_STATEMENT' }</action_statement>\n" if ($trigger_bodies eq 1);
          $return_string .= "    </trigger>\n";

        }

      }

      $return_string .= "  </table>\n\n";

    }

    if ( $udfs eq 1 || $udf_bodies eq 1 ) {

      for my $udf (keys(%{$doc_info{ $database }{ 'PROCEDURES' } })) {

        $return_string .= "  <procedure name='$udf' type='$doc_info{ $database }{ 'PROCEDURES' }{ $udf }{ 'ROUTINE_TYPE' }'>\n";

        $return_string .= "      <td><pre>$doc_info{ $database }{ 'PROCEDURES' }{ $udf }{ 'ROUTINE_DEFINITION' }</pre></td>\n" if ( $udf_bodies eq 1 );

        $return_string .= "\n  </procedure>\n";

      }

    }

    $return_string .= "</database>\n";

  } case 'HTML' {


    $return_string .= "  <h1><strong>DATA DICTIONARY FOR: $database";
    $return_string .= " ($ts)" if ($timestamp eq 1);
    $return_string .= "</strong></h1>\n";

    for my $table (keys(%{$doc_info{ $database }{ 'TABLES' } })) {

      $return_string .= ($doc_info{ $database }{ 'TABLES' }{ $table }{ 'TABLE_TYPE' } ne 'VIEW' ? "  <dl>\n    <dt>Table Name</dt>\n      <dd>$table " : "  <dl>\n    <dt>View Name</dt>\n      <dd>$table ");

      $return_string .= "- ($doc_info{ $database }{ 'TABLES' }{ $table }{ 'TABLE_TYPE' }";

      if ($engines eq 1 && $doc_info{ $database }{ 'TABLES' }{ $table }{ 'TABLE_TYPE' } ne 'VIEW') {

        $return_string .= " ";

        if ($links eq 1) {

          switch ($doc_info{ $database }{ 'TABLES' }{ $table }{ 'ENGINE' }) {

            case 'InnoDB' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/innodb.html'>"; }
            case 'MyISAM' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/myisam-storage-engine.html'>"; }
            case 'MEMORY' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/memory-storage-engine.html'>"; } 
            case 'MERGE' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/merge-storage-engine.html'>"; }
            case 'BDB' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/bdb-storage-engine.html'>"; }
            case 'EXAMPLE' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/example-storage-engine.html'>"; }
            case 'FEDERATED' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/federated-storage-engine.html'>"; }
            case 'ARCHIVE' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/archive-storage-engine.html'>"; }
            case 'CSV' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/csv-storage-engine.html'>"; }
            case 'BLACKHOLE' { $return_string .= "<a href='http://dev.mysql.com/doc/refman/$mysql_version/en/blackhole-storage-engine.html'>"; }
          
          }
     
        }

        $return_string .= "$doc_info{ $database }{ 'TABLES' }{ $table }{ 'ENGINE' }";

        $return_string .= "</a>" if ($links eq 1);

      }

      $return_string .= ")</dd>\n";

      if ($doc_info{ $database }{ 'TABLES' }{ $table }{ 'TABLE_TYPE' } ne 'VIEW') {

        $return_string .= "    <dt>Table Stats</dt>\n      <dd>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'TOTAL_SIZE' } MB (DATA: $doc_info{ $database }{ 'TABLES' }{ $table }{ 'DATA_LENGTH' } MB, INDEX: $doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEX_LENGTH' } MB)</dd>\n";

        $return_string .= "    <dt>Table Contents</dt>\n      <dd>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'COMMENT' }</dd>\n" if ($doc_info{ $database }{ 'TABLES' }{ $table }{ 'COMMENT' });

      }

      $return_string .= "  </dl>\n  <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">
    <tr>
      <th>Column Name</th>
      <th>Data Type</th>
      <th>Default Value</th>
      <th>Description</th>
    </tr>\n";
 
      for my $column (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table }->{ 'COLUMNS' } })) {

        $return_string .= "    <tr>\n      <td>$column</td>\n      <td>"; 
        $return_string .= $doc_info{ $database }{ 'TABLES' }{ $table }{ 'COLUMNS' }{ $column }{ 'DATA_TYPE' };
        $return_string .= "</td>\n      <td>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'COLUMNS' }{ $column }{ 'DEFAULT' }" if ($doc_info{ $database }{ 'TABLES' }{ $table }{ 'COLUMNS' }{ $column }{ 'DEFAULT' });

        $return_string .= "</td>\n";

        $return_string .= "      <td>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'COLUMNS' }{ $column }{ 'COMMENT' }</td>\n" if ($doc_info{ $database }{ 'TABLES' }{ $table }{ 'COLUMNS' }{ $column }{ 'COMMENT' });
        $return_string .= "    </tr>\n";

      }

      $return_string .= "  </table>\n";

      if ($indexes eq 1) {

        $return_string .= "  <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">
    <tr>
      <th>Index Name</th>
      <th>Index Type</th>
      <th>Affected Column(s)</th>
    </tr>\n";

        for my $index (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table }->{ 'INDEXES' } })) {

          $return_string .= "    <tr>\n     <td>$index</td>\n      <td>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }{ 'INDEX_TYPE' }</td>\n      <td>";

          my $column_count = keys %{$doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }{ 'COLUMNS' } };

          if ($column_count gt 1) {

            for (my $i = 1; $i < $column_count + 1; $i++) {

              for my $i_col (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }->{ 'COLUMNS' } })) {

                if ($doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }{ 'COLUMNS' }{ $i_col }->{ 'SEQ_IN_INDEX' } eq $i) {

                  $return_string .= "$i_col";

                  $return_string .= ($i < $column_count) ? ", " : "</td>\n    </tr>\n";

                }

              }

            }

          } else {

            # This sucks, but I don't know another way
            for my $s (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }{ 'COLUMNS' } })) {

              $return_string .= "$s</td>\n    </tr>\n\n";

            }

          }

        }

        $return_string .= "  </table>\n";

      }

      if ($triggers eq 1 || $trigger_bodies eq 1) {

        my $trigger_count = keys %{$doc_info{ $database }{ 'TABLES' }{ $table }{ 'TRIGGERS' } };

        if ($trigger_count gt 0) {

          $return_string .= "  <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">
    <tr>
      <th>Trigger Name</th>
      <th>Action Timing</th>
      <th>Event Manipulation</th>\n";
        $return_string .= "      <th>Body</th>\n" if ($trigger_bodies eq 1);
        $return_string .= "    </tr>\n";

          for my $trigger (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table }->{ 'TRIGGERS' } })) {

            $return_string .= "    <tr>\n      <td>$trigger</td>\n";
            $return_string .= "      <td>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'TRIGGERS' }{ $trigger }{ 'ACTION_TIMING' }</td>\n";
            $return_string .= "      <td>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'TRIGGERS' }{ $trigger }{ 'EVENT_MANIPULATION' }</td>\n";
            $return_string .= "      <td><pre>$doc_info{ $database }{ 'TABLES' }{ $table }{ 'TRIGGERS' }{ $trigger }{ 'ACTION_STATEMENT' }</pre></td>\n" if ($trigger_bodies eq 1);
            $return_string .= "    </tr>\n";

          }

          $return_string .= "  </table>\n";

        }

        if ( $udfs eq 1 || $udf_bodies eq 1 ) {

          $return_string .= "  <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">
    <tr>
      <th>UDF Name</th>
      <th>UDF Type</th>\n";
          $return_string .= "      <th>Event Manipulation</th>\n" if ($udf_bodies eq 1);;

          for my $udf (keys(%{$doc_info{ $database }{ 'PROCEDURES' } })) {

            $return_string .= "    <tr>\n      <td>$udf</td>\n       <td>$doc_info{ $database }{ 'PROCEDURES' }{ $udf }{ 'ROUTINE_TYPE' }</td>\n";
            $return_string .= "      <td><pre>$doc_info{ $database }{ 'PROCEDURES' }{ $udf }{ 'ROUTINE_DEFINITION' }</pre></td>\n" if ( $udf_bodies eq 1 );

          }

          $return_string .= "  </table>\n";

        }

      } 

      }

    } else {

      $return_string .= "\nDATA DICTIONARY FOR: $database";
      $return_string .= " ($ts)" if ($timestamp eq 1);
      $return_string .= "\n\n";

      for my $table (keys(%{$doc_info{ $database }{ 'TABLES' } })) {

        $return_string .= "$table - ($doc_info{ $database }{ 'TABLES' }{ $table }{ 'TABLE_TYPE' }";

        if ($doc_info{ $database }{ 'TABLES' }{ $table }{ 'TABLE_TYPE' } ne 'VIEW') {

          $return_string .= " $doc_info{ $database }{ 'TABLES' }{ $table }{ 'ENGINE' }" if ($engines eq 1);

          $return_string .= ") $doc_info{ $database }{ 'TABLES' }{ $table }{ 'TOTAL_SIZE' } MB (DATA: $doc_info{ $database }{ 'TABLES' }{ $table }{ 'DATA_LENGTH' } MB, INDEX: $doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEX_LENGTH' } MB)\n";
        }

        $return_string .= "  $doc_info{ $database }{ 'TABLES' }{ $table }{ 'COMMENT' }\n";
       
        for my $column (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table }->{ 'COLUMNS' } })) {

          $return_string .= "  $column - ";
          $return_string .= $doc_info{ $database }{ 'TABLES' }{ $table }{ 'COLUMNS' }{ $column }{ 'DATA_TYPE' };

          $return_string .= "  DEFAULT $doc_info{ $database }{ 'TABLES' }{ $table }{ 'COLUMNS' }{ $column }{ 'DEFAULT' }" if ($doc_info{ $database }{ 'TABLES' }{ $table }{ 'COLUMNS' }{ $column }{ 'DEFAULT' });

          $return_string .= "\n      $doc_info{ $database }{ 'TABLES' }{ $table }{ 'COLUMNS' }{ $column }{ 'COMMENT' }\n";

        }

       if ($indexes eq 1) {

         for my $index (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table }->{ 'INDEXES' } })) {

            $return_string .= "  $index ($doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }{ 'INDEX_TYPE' } INDEX)\n      ";

            my $column_count = keys %{$doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }{ 'COLUMNS' } };

            if ($column_count gt 1) {
 
              for (my $i = 1; $i < $column_count + 1; $i++) {

                for my $i_col (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }->{ 'COLUMNS' } })) {

                  if ($doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }{ 'COLUMNS' }{ $i_col }->{ 'SEQ_IN_INDEX' } eq $i) {

                    $return_string .= "$i_col";

                    $return_string .= ($i < $column_count) ? ", " : "\n";

                  }

                }

              }

            } else {

              # This sucks, but I don't know another way
              for my $s (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table }{ 'INDEXES' }{ $index }{ 'COLUMNS' } })) {

                $return_string .= "$s\n";

              }

            }
 
          }

        }

        if ($triggers eq 1 || $trigger_bodies eq 1) {

          for my $trigger (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table }->{ 'TRIGGERS' } })) {

            $return_string .= "  $trigger (TRIGGER) - $doc_info{ $database }{ 'TABLES' }{ $table }{ 'TRIGGERS' }{ $trigger }{ 'ACTION_TIMING' } $doc_info{ $database }{ 'TABLES' }{ $table }{ 'TRIGGERS' }{ $trigger }{ 'EVENT_MANIPULATION' }\n";
            $return_string .= "    $doc_info{ $database }{ 'TABLES' }{ $table }{ 'TRIGGERS' }{ $trigger }{ 'ACTION_STATEMENT' }\n" if ($trigger_bodies eq 1);

          }

        }

      }

      if ( $udfs eq 1 || $udf_bodies eq 1 ) {
  
        for my $udf (keys(%{$doc_info{ $database }{ 'PROCEDURES' } })) {

          $return_string .= "\n  $udf ($doc_info{ $database }{ 'PROCEDURES' }{ $udf }{ 'ROUTINE_TYPE' })\n";
          $return_string .= "      $doc_info{ $database }{ 'PROCEDURES' }{ $udf }{ 'ROUTINE_DEFINITION' }\n" if ( $udf_bodies eq 1 ); 

        }     

      }

    }

  }

}

$return_string .= &buildOutputFooters(uc($output));

if ($filename) {

  open(OUTFILE, ">$filename") or die "Can't open $filename for writing : $!";
  print OUTFILE $return_string;
  close(OUTFILE);

} else {

  print $return_string;

}

sub getPass {

  print "Password: ";
  system "stty -echo";
  chomp(my $passwd = <STDIN>);
  system "stty echo";
  print "\n";
  return $passwd;

}

sub buildOutputHeaders ($$) {

  my $rs;

  switch ($_[0]) {

    case 'HTML' { 
 
      $rs  = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
  <title>DATA DICTIONARY FOR: ' .  join(', ', @databases); 

      $rs .= " ($ts)" if ($timestamp eq 1);

      $rs .= "</title>
  <style type=\"text/css\">
    body {font-family:Arial;}
    h1 {text-align:center;}
    table {margin-bottom:1em;}
    tr td {border-bottom:1px solid #ccc; 
           border-right:1px solid #ccc;
           padding:3px 8px; 
           border-collapse: collapse;}
    tr:hover {background-color:#FFFFCC;}
    th {text-align:left;padding:3px 8px;}
   </style>\n</head>\n\n<body>\n\n";

    } case 'XML' { 

      $rs = '<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE databases [
  <!ELEMENT databases (database*)>
  <!ELEMENT database (table*)>
  <!ELEMENT table (column*, index*, trigger*)>
  <!ELEMENT column (data_type, default_value, comment)>
  <!ELEMENT index (index_type, indexed_column*)>
  <!ELEMENT trigger (action_timing, event_manipulation, action_statement?)>

  <!ELEMENT data_type (#PCDATA)>
  <!ELEMENT default_value (#PCDATA)>
  <!ELEMENT comment (#PCDATA)>
  <!ELEMENT index_type (#PCDATA)>
  <!ELEMENT indexed_column (#PCDATA)>
  <!ELEMENT action_timing (#PCDATA)>
  <!ELEMENT event_manipulation (#PCDATA)>
  <!ELEMENT action_statement (#PCDATA)>

  <!ATTLIST database name CDATA #REQUIRED
                     timestamp CDATA #IMPLIED>
  <!ATTLIST table name CDATA #REQUIRED
                  type CDATA #REQUIRED
                  engine CDATA #IMPLIED
                  total_size CDATA #IMPLIED
                  data_size CDATA #IMPLIED
                  index_size CDATA #IMPLIED>
  <!ATTLIST column name CDATA #REQUIRED>
  <!ATTLIST index name CDATA #REQUIRED>
  <!ATTLIST indexed_column seq_in_index CDATA #REQUIRED>
  <!ATTLIST trigger name CDATA #REQUIRED>

]>

<databases>
';

    } case 'TXT' { }

  }

  return $rs;

}

sub buildOutputFooters ($$) {

  my $rs = '';

  switch ($_[0]) {

    case 'HTML' {

      $rs = "\n\n<p>Generated By: <a href='http://code.google.com/p/mysqldoc'>mysqldoc</a> $mysqldoc_version</p>\n\n</body>\n\n</html>";

    } case 'XML' {

      $rs = '</databases>';

    }

  }

  return $rs;
 
}

sub getBaseInfo($$) {

  my $database = $_[0];

  my $query = $dbh->prepare("SELECT `t`.`TABLE_NAME`, 
                                    `t`.`TABLE_TYPE`, 
                                    `t`.`ENGINE`, 
                                    IFNULL(`t`.`DATA_LENGTH`, 0) AS `DATA_LENGTH`, 
                                    IFNULL(`t`.`INDEX_LENGTH`, 0) AS `INDEX_LENGTH`, 
                                    `t`.`TABLE_COMMENT`,        
                                    `c`.`COLUMN_NAME`,
                                    `c`.`COLUMN_TYPE`,
                                    IFNULL(`c`.`CHARACTER_MAXIMUM_LENGTH`, `c`.`NUMERIC_PRECISION`) AS `MAX_LENGTH`,
                                    IFNULL(`c`.`COLUMN_DEFAULT`, IF(`c`.`IS_NULLABLE` = 'NO','','NULL')) AS `COLUMN_DEFAULT`,
                                    `c`.`COLUMN_COMMENT`
                                FROM `INFORMATION_SCHEMA`.`TABLES` `t` 
                                JOIN `INFORMATION_SCHEMA`.`COLUMNS` `c` ON (`t`.`TABLE_SCHEMA` = `c`.`TABLE_SCHEMA` AND `t`.`TABLE_NAME` = `c`.`TABLE_NAME`)     
                                  WHERE `t`.`TABLE_SCHEMA` = \"$database\"") or die "Couldn't prepare statement: " . $dbh->errstr;

  $query->execute() or die "Couldn't execute statement: " . $dbh->errstr;

  while (my $ref = $query->fetchrow_hashref()) {

    unless (exists($doc_info{ $database }{ 'TABLES' }{ $ref->{ 'TABLE_NAME' } })) {

      $doc_info{ $database }{ 'TABLES' }{ $ref->{ 'TABLE_NAME' } } = { 'TABLE_TYPE'   => $ref->{ 'TABLE_TYPE' },
                                                                       'ENGINE'       => $ref->{ 'ENGINE' },
                                                                       'TOTAL_SIZE'   => $ref->{ 'DATA_LENGTH' } + $ref->{ 'INDEX_LENGTH' },
                                                                       'DATA_LENGTH'  => $ref->{ 'DATA_LENGTH' },
                                                                       'INDEX_LENGTH' => $ref->{ 'INDEX_LENGTH' },
                                                                       'COMMENT'      => $ref->{ 'TABLE_COMMENT' } };

    }

    $doc_info{ $database }{ 'TABLES' }{ $ref->{ 'TABLE_NAME' } }{ 'COLUMNS' }{ $ref->{ 'COLUMN_NAME' } } =  { 'DATA_TYPE'  => $ref->{ 'COLUMN_TYPE' },
                                                                                                              'MAX_LENGTH' => $ref->{ 'MAX_LENGTH' },
                                                                                                              'DEFAULT'    => $ref->{ 'COLUMN_DEFAULT' },
                                                                                                              'COMMENT'    => $ref->{ 'COLUMN_COMMENT' } };
  
  }

}

sub getIndexInfo($$) {

  my $database = $_[0];
  my $table_name = $_[1];

  my $index_query = $dbh->prepare("SELECT `INDEX_NAME`, `COLUMN_NAME`, `SEQ_IN_INDEX` FROM `INFORMATION_SCHEMA`.`STATISTICS`
                                   WHERE `TABLE_SCHEMA` = \"$database\" AND `TABLE_NAME` = \"$table_name\" GROUP BY `INDEX_NAME`,
                                   `COLUMN_NAME` ORDER BY `INDEX_NAME`, `SEQ_IN_INDEX`") or die "Couldn't prepare statement: " . $dbh->errstr;

  $index_query->execute() or die "Couldn't execute statement: " . $dbh->errstr;

  while (my $ref = $index_query->fetchrow_hashref()) {

    $doc_info{ $database }{ 'TABLES' }{ $table_name }{ 'INDEXES '}{ $ref->{ 'INDEX_NAME' } }{ 'COLUMNS' }{ $ref->{ 'COLUMN_NAME' } } = { 'SEQ_IN_INDEX' => $ref->{ 'SEQ_IN_INDEX' } };

  }

  for my $index (keys(%{$doc_info{ $database }{ 'TABLES' }{ $table_name }{ 'INDEXES' } })) {

    my $itq = $dbh->prepare("SELECT DISTINCT `INDEX_TYPE` FROM `INFORMATION_SCHEMA`.`STATISTICS` WHERE `TABLE_SCHEMA` = \"$database\" AND
                            `TABLE_NAME` = \"$table_name\" AND `INDEX_NAME` = \"$index\"") or die "Couldn't prepare statement: " . $dbh->errstr;

    $itq->execute() or die "Couldn't execute statement: " . $dbh->errstr;

    $doc_info{ $database }{ 'TABLES' }{ $table_name }{ 'INDEXES' }{ $index }{ 'INDEX_TYPE' } =  $itq->fetchrow();

  }

}

sub getTriggerInfo($$) {

  my $database = $_[0];
  my $table_name = $_[1];

  my $trigger_query = $dbh->prepare("SELECT `trigger_name`, `action_timing`, `event_manipulation`, `action_statement` FROM `INFORMATION_SCHEMA`.`TRIGGERS`
                                    WHERE `TRIGGER_SCHEMA` = \"$database\" AND `EVENT_OBJECT_TABLE` = \"$table_name\"") or die "Couldn't prepare statement: " . $dbh->errstr;

  $trigger_query->execute() or die "Couldn't execute statement: " . $dbh->errstr;

  while (my $ref = $trigger_query->fetchrow_hashref()) {

    $doc_info{ $database }{ 'TABLES' }{ $table_name }{ 'TRIGGERS' }{ $ref->{ 'trigger_name' } } = { 'ACTION_TIMING'      => $ref->{ 'action_timing' },
                                                                                                    'EVENT_MANIPULATION' => $ref->{ 'event_manipulation' },
                                                                                                    'ACTION_STATEMENT'   => $ref->{ 'action_statement' } };

  }

}

sub getUdfInfo($$) {

  my $database = $_[0];

  my $udf_query = $dbh->prepare("SELECT `ROUTINE_NAME`, `ROUTINE_TYPE`, `ROUTINE_DEFINITION` FROM `INFORMATION_SCHEMA`.`ROUTINES` WHERE `ROUTINE_SCHEMA` = \"$database\"") or die "Couldn't prepare statement: " . $dbh->errstr;

  $udf_query->execute() or die "Couldn't execute statement: " . $dbh->errstr;

  while (my $ref = $udf_query->fetchrow_hashref()) {

    $doc_info{ $database }{ 'PROCEDURES' }{ $ref->{ 'ROUTINE_NAME' } } = { 'ROUTINE_TYPE'       => $ref->{ 'ROUTINE_TYPE' },
                                                                           'ROUTINE_DEFINITION' => $ref->{ 'ROUTINE_DEFINITION' } };

  }

}

